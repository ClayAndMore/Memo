tags: [python, 正则表达式] date: 2017-03-02


### 写在前面
正则表达式通过一个表达式来设定正确的规则，验证的时候只要询问输入的字符串是否符合这个表达式就可以了。

### 规则
先看一个只允许中文字符的正则表达：
`^[\u4e00-\u9fa5]{4,20}$`

* ^和$在正则表达式中分别代表开头和结尾，这里说必须以中文开头，中文结尾
* []的目的是设定匹配的什么，如果写[abc]那么字符串中只允许有abc这三个字母，如果是[a-z]就允许所有的小写字母，在上面[]中说明的是中文。
* {4,,20}表示允许的位数，这里允许4到20位字符。
* []{}写到一起是为了展示正则表达式的能力，内容错误和字数错误会有不同提示，一般会分开写。
* () 是为了提取匹配的字符串。表达式中有几个()就有几个相应的匹配字符串。

### 样例
```html
<script>
    str = "搜狐邮箱用户登陆"
    reg = /^[\u4e00-\u9fa5]{4,20}$/;
    alert(reg.test(str));
<script>
```
这是在js中使用正则表达式，注意的是赋值并没有用字符串，不能使用双引号，而是用两个/，这样reg就有test方法了（验证是否符合所代表的规则），返回值是true和false。
还有exec方法，返回值是null，意味着不匹配，返回值是字符串，意味着匹配上了什么字符串。
像上面就会返回true，如果改为str="构建jave工程"，则会false，如果允许既有中文又有英文会变为：`/^[\u4e00-\u9fa5a-z A-Z]{4,20}$/`
具体可查表

#### 单个字符
```
.          任意的一个字符
a|b        字符a或字符b
[afg]      a或者f或者g的一个字符        
[0-4]      0-4范围内的一个字符
[a-f]      a-f范围内的一个字符
[^m]       不是m的一个字符
\t         一个制表符
\s         一个空格
\S         一个非空格
\d         [0-9]
\D         [^0-9]
\w         [0-9a-zA-Z]
\W         [^0-9a-zA-Z]
```



#### 重复
紧跟在单个字符之后，表示多个这样类似的字符：
```
*         重复 >=0 次
+         重复 >=1 次
?         重复 0或者1 次
{m}       重复m次。比如说 a{4}相当于aaaa，再比如说[1-3]{2}相当于[1-3][1-3]
{m, n}    重复m到n次。比如说a{2, 5}表示a重复2到5次。小于m次的重复，或者大于n次的重复都不符合条件。
```
| 正则表达       | 相符的字符串举例 |
| :--------- | :------- |
| [0-9]{3,5} | 9678     |
| a?b        | b        |
| a+b        | aaaaab   |



#### 特殊

匹配点，问号，括号等需要加转义，如匹配百分小数和括号内：

```
>>> p = re.compile(r'\d+\.\d% \(\.[A-Z]+\)')
>>> s='29.2% (.ISO)9600 CD image'
>>> p.findall(s)
['29.2% (.ISO)']
```

findall后续会说



### 修饰符

```python
import re
content = 'Hello 1234567 World_This is a Regex Demo'
res = re.match("^He.*?(\d+).*Demo$",content)
print(res.group(1))
1234567

# 我们把content换成"Hello 1234567 
# World_This is a Regex Demo", 就匹配不到了，这是为什么呢
```

因为.匹配的是除换行符之外的任意字符， 当遇到换行符时，`.*?`就不能匹配类， 所以我们要加个：

`re.S`即可修正这个错误。

其他修饰符：

```python
re.I  使匹配对大小写不敏感
re.U， 根据Unicode字符集解析字符，影响\w,\W,\b,\B
re.L
re.M
re,X
```

不常用的没写。





### python中的正则

Python提供`re`模块，包含所有正则表达式的功能。由于Python的字符串本身也用`\`转义，所以要特别注意：

```
s = 'ABC\\-001' # Python的字符串
# 对应的正则表达式字符串变成：
# 'ABC\-001'

```

因此我们强烈建议使用Python的`r`前缀，就不用考虑转义的问题了：

```
s = r'ABC\-001' # Python的字符串
# 对应的正则表达式字符串不变：
# 'ABC\-001'
```



#### match

`match()`方法判断是否匹配，如果匹配成功，返回一个`Match`对象，否则返回`None`。常见的判断方法就是：

```python
test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')
```

但是match只能匹配一个字符串的开始位置：

```python
In [1]: m = re.match(r'[0-9]{2}','12dfdfs/n')
In [2]: m
Out[3]: <_sre.SRE_Match object; span=(0, 2), match='12'>
---
In [4]: m = re.match(r'[0-9]{2}','d44fdfs/n')
In [5]: m
```

可见，第二次匹配是失败的。

 

#### search

search函数会在字符串内查找模式匹配，只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None;

```
In [10]: m = re.search(r'[0-9]{2}','d44fdfs/n')
In [11]: m
Out[11]: <_sre.SRE_Match object; span=(1, 3), match='44'>
```



#### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。比如：

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```python
>>> m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
>>> m
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'
```

如果正则表达式中定义了组，就可以在`Match`对象上用`group()`方法提取出子串来。

注意到`group(0)`永远是原始字符串，`group(1)`、`group(2)`……表示第1、2、……个子串。

提取子串非常有用。来看一个更凶残的例子：

```
>>> t = '19:05:30'
>>> m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
>>> m.groups()
('19', '05', '30')
```

这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：

```
'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$'
```

对于`'2-30'`，`'4-31'`这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了



#### 贪婪匹配

最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的`0`：

```
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')

```

由于`\d+`采用贪婪匹配，直接把后面的`0`全部匹配了，结果`0*`只能匹配空字符串了。

必须让`\d+`采用非贪婪匹配（也就是尽可能少匹配），才能把后面的`0`匹配出来，加个`?`就可以让`\d+`采用非贪婪匹配：

```
>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')
```



#### 编译compile

当我们在Python中使用正则表达式时，re模块内部会干两件事情：

1. 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
2. 用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：

```python
>>> import re
# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')
```

编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。

**匹配多行**



#### findall

```python
>>> p = re.compile(r'\d+\.\d% \(\.[A-Z]+\)')
>>> s='29.2% (.ISO)9600 CD image，29.2% (.ISO)9600 CD image'
>>> p.findall(s)
['29.2% (.ISO)'， '29.2% (.ISO)']
```



会匹配多个，而不是匹配到一个就退出



#### sub()

有时候需要修改文本，比如把一串文本等所有数字都去掉。

如果只用字符串的replace方法，太繁琐了，可以借助re的sub方法：

```python
content="54abc434de323f"
content=re.sub('\d+','',content)
print(content)
abcdef
```



#### 匹配换行

re.compile()函数可接受一个有用的标记：re.DOTALL，这使得表达式中的句点【.】可以匹配所有的字符，也包括换行符。

```python
>>> import re
>>> p=re.compile(r'a')
>>> s = '''
...  dsfa
...  sas
... '''
>>> p.findall(s)
['a', 'a']
>>> p=re.compile(r'a.')
>>> p.findall(s)
['as']
>>> p=re.compile(r'a.', re.DOTALL)
>>> p.findall(s)
['a\n', 'as']
```





#### 练习

请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email：

```
someone@gmail.com
bill.gates@microsoft.com
```

版本二可以验证并提取出带名字的Email地址：

```
<Tom Paris> tom@voyager.org
```

```python
import re
email=re.compile(r'^(\w+\.?)*\w+@\w+\.\w+$')
print(email.match('someone@gmail.com').group(0))
print(email.match('bill.gates@microsoft.com').group(0))

----
someone@gmail.com
bill.gates@microsoft.com

import re
re_email=re.compile(r'^<(.*)>\s*((\w+\.?)*\w+@\w+\.\w+)$')
email='<Tom Paris> tom@voyager.org'
a=re_email.match(email)
if a:
    print('邮箱%s匹配正确，名字是%s，邮箱是%s'%(a.group(0),a.group(1),a.group(2)))
else:
    print('邮箱 %s 匹配失败！'% email)
    
----
邮箱<Tom Paris> tom@voyager.org匹配正确，名字是Tom Paris，邮箱是tom@voyager.org
```



### 一些实例

#### ip 

`r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'`

| 匹配    | 正则表达式 | 说明                                |
| ------- | ---------- | ----------------------------------- |
| 0-9     | d          | 单个数字                            |
| 10-99   | [1-9]d     | 两位数                              |
| 100-199 | 1dd        | 百位为1的三位数                     |
| 200-249 | 2[0-4]d    | 三位数，百位是2，十位是0-9          |
| 250-255 | 25[0-5]    | 三位数，百位是2，十位是5，个位是0-5 |

`(d|([1-9]d) | (1dd) | (2[0-4]d) | (25[0-5]))`，但是这样的正则表达式在匹配254这样的字串时，会分别匹配2、5、4，得到3个匹配，达不到预期效果，正确做法是将次序颠倒为：`((25[0-5])|(2[0-4]d)|(1dd)|([1-9]d)|d)`，因为在`(xxx|yyy)`这种匹配行为中，是从左向右搜索的。



#### 域名

```python
# 域名正则， 匹配ntp服务器，可能形式：
# utcnist.colorado.edu
# time-a.timefreq.bldrdoc.gov
DOMAIN_NAME_RE = r'^(((([A-Za-z0-9]+){1,63}\.)|(([A-Za-z0-9]+(\-)+[A-Za-z0-9]+){1,63}\.))+)([A-Za-z0-9]{1,18})$'
```



#### 中文

匹配中文:`[\u4e00-\u9fa5]`

匹配中文，英文字母和数字及_: 

`^[\u4e00-\u9fa5_a-zA-Z0-9]+$`

有时匹配不上记得加ur, 如 : `ur'^[\u4e00-\u9fa5_a-zA-Z0-9]+$'`