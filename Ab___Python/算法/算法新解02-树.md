### 二叉树

二叉树可以递归地定义如下：

* 或者为空
* 或者包含三部分：一个值，一个左分支一个右分支，并且这两个分支也是二叉树。



叶子节点： 一个节点的左右孩子都为空，则称为叶子节点。



#### 遍历

前序遍历： 根节点 -> 左子树 -> 右子树,  4 3 1 2 8 7 16 10 9 14

中序遍历： 左子树 -> 根节点 -> 右子树   1 2 3 4 7 8 9 10 14 16

后序遍历： 左子树 -> 右子树 -> 根节点   2 1 3 7 9 14 10  16  8 4

ps,前中序对于根节点的访问顺序来说的。 

遍历时，要深入当下节点的孩子。



定义节点：

```python
class TreeNode(object):
	def __init__(self, x):
		self.val = x
		self.left = None
		self.right = None
"""构造
Constructed binary tree is 
            1 
          /   \ 
         2     3 
       /  \ 
      4    5   """
  
root = Node(1) 
root.left = Node(2) 
root.right = Node(3) 
root.left.left = Node(4) 
root.left.right = Node(5) 
  
"""
```

前中序遍历：

```python
class Solution(object):  
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root: return []
        res = []
        # 这是中序遍历，其他遍历方式只要改下顺序即可。
        res += self.inorderTraversal(root.left)
        res.append(root.val)
        res += self.inorderTraversal(root.right)
        
        return res
```



非递归：

```python
    def inorderTraversal(self, root):
        current = root
        stack = []
        res = []
        jump = False
        while not jump:
            if current:
                stack.append(current)
                current = current.left
            else:
                if len(stack) > 0:
                    current = stack.pop()
                    res.append(current.val)
                    current = current.right
                else:
                    jump = True
        return res


def pre_order_not_recursion(root):
    if not isinstance(root, Node):
        return None

    stack = [root]
    result = []
    while stack:
        node = stack.pop(-1)
        if node:
            result.append(node.value)
            stack.append(node.right_child)
            stack.append(node.left_child)
    return result

def middle_order_bot_recursion(root):
    if not isinstance(root, Node):
        return None

    result = []
    stack = [root.right_child, root.value, root.left_child]
    while stack:
        temp = stack.pop(-1)
        if temp:
            if isinstance(temp, Node):
                stack.append(temp.right_child)
                stack.append(temp.value)
                stack.append(temp.left_child)
            else:
                result.append(temp)
    return result

def post_order_not_recursion(root):
    if not isinstance(root, Node):
        return None

    stack = [root.value, root.right_child, root.left_child]
    result = []

    while stack:
        temp_node = stack.pop(-1)
        if temp_node:
            if isinstance(temp_node, Node):
                stack.append(temp_node.value)
                stack.append(temp_node.right_child)
                stack.append(temp_node.left_child)
            else:
                result.append(temp_node)

    return result
```



层序遍历，用队列

```python
    def BFS(self,root):              #层次遍历核心代码
        if root == None:
            return
        queue = []
        queue.append(root)
 
        while queue:
            now_node = queue.pop(0)
            print(now_node.data)
            if now_node.left != None:
                queue.append(now_node.left)
            if now_node.right != None:
                queue.append(now_node.right)
```





### 二叉搜索树

* 所有左分支的值都小于本节点的值。
* 本节点的值小于所有右分支的值。

![](http://www.claymore.wang:5000/uploads/big/fd2f9dede94ea947728942da52a7257f.png)





### 红黑树







### AVL树









### B 树

