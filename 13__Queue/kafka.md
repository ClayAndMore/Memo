
---
title: "kafka.md"
date: 2019-09-29 17:53:13 +0800
lastmod: 2019-09-29 17:53:13 +0800
draft: false
tags: [""]
categories: [""]
author: "Claymore"

---
Tags:[linux, linux_software]

### 写在前面

**Kafka是分布式的发布—订阅消息系统**。

初由LinkedIn公司开发，之后成为Apache项目的一部分 ：https://kafka.apache.org/

Kafka 基于zookeeper协调的分布式消息队列系统 ,



分布式消息系统kafka提供了一个生产者、缓冲区、消费者的模型 

```
 producer     producer     producer
	   \	    |	     /
	     \	    |	   /
	       \	|	 /
	    	kafka cluster
	    	/    |    \
	       /     |	    \
  consumer     conseumer  conseumer
```

Kafka中，客户端和服务器之间的通信是通过简单，高性能，语言无关TCP协议完成的。此协议已版本化并保持与旧版本的向后兼容性。客户端有多种语言版本



#### 几个术语

##### broker（经济人）

指的是中间的kafka cluster，存储消息数据，存在硬盘中，可以是由多个server组成的集群 

Kakfa Broker集群受Zookeeper管理 



##### topics 

kafka给消息提供的分类方式。broker用来存储不同topic的消息数据 。

```
       A topic:
------------------------------------------------
| Partition 0:  0,1,2,3,4,5.....               |
| Partition 1:  0,1,2,3,4,5,6,7,8,9,10, 11 ..  |
| Partition 2:  0,1,2..                        |
------------------------------------------------
time: old  -------------> new
```

* 每个topic又可以拆分成多个partition , partition均匀分配到集群server中 
* 每个partition又由一个一个消息组成 
* 每个消息都被标识了一个递增序列号代表其进来的先后顺序，并按顺序存储在partition中 
* 一个topic 可以在不同的机器上，每个机器有不同的Partition.

一个分区（partition）只支持一个消费线程来消费消息。过少的分区，会导致消费速度大大落后于消息的生产速度。所以在实际生产环境中，一个Topic会设置成多分区的模式，来支持多个消费者。多 Partition 是分布在不同机器上的，可以实现broke水平扩展。



**producer选择一个topic，生产消息，消息会通过分配策略append到某个partition末尾** 

**consumer选择一个topic，通过id指定从哪个位置开始消费消息。消费完成之后保留id，下次可以从这个位置开始继续消费，也可以从其他任意位置开始消费** 

这个id, 在Kafaka中被称为offset.



这种组织方式的好处：

1. 消费者可以根据需求，灵活指定offset消费
2. 保证了消息不变性，为并发消费提供了线程安全的保证。每个consumer都保留自己的offset，互相之间不干扰，不存在线程安全问题 。
3. 消息访问的并行高效性。生产、消费消息的时候，会被路由到指定partition，减少竞争，增加了程序的并行能力 
4. 保证消息可靠性。**消息消费完成之后不会删除**，可以通过重置offset重新消费，保证了消息不会丢失 ，可以设置消息保留日期。
5. 增加消息系统的可伸缩性。每个topic中保留的消息可能非常庞大，通过partition将消息切分成多个子消息，并通过负责均衡策略将partition分配到不同server。这样当机器负载满的时候，通过扩容可以将消息重新均匀分配 



##### producer

数据生产者，消费者

producer和consumer 都是客户端（APP）



##### consumer

传统来看， 消息有两种模型：

* 队列： 一池子的消费者从一个server中读取消息，每条消息只被发给其中的一个消费者
* 发布-订阅： 消息被广播给所有的消费者

Kafka提供了一个单消费者的抽象--消费者组，它可以同时兼容两种模型。

消费者用一个组名(conssumer group)标记它们自己,：

1. 每一条发布的消息会被传递给所有订阅了这个主题的消费者组（发布-订阅模式）
2. 每个消费者组只会有一个消费者接收到这条消息。消费者组中的消费者实例可以是不同的进程或者干脆在不同的机器上。（队列模式）



如果所有的消费者都在同一个组下面，那么就和传统队列模型一样，消费者之间会进行负载均摊。

如果所有的消费者都有不同的组名，那么就和发布-订阅模型是一样，所有的消息都会被广播给所有的消费者。


