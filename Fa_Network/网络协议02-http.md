Tags:[网络协议]



HTTP最初的目的是为了让研究者共享知识信息，所以它的主要作用就是文档传输，它是一种用于传输文档的协议。

HTTP是不保存状态的协议，既无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。这也是Cookie技术产生的重要原因之一：客户端的状态管理。浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保持 Cookie。而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务端识别客户端身份状态的标识。



### http协议

分为两部分：

#### 浏览器向服务器的请求request:

**请求行request line，请求头部header，空行blank，请求数据body**

![](http://claymore.wang:5000/uploads/big/318d24be137b3a90e55fe010aa634c83.png)

eg:

get请求例子：

```http
GET /562f25980001b1b106000338.jpg HTTP/1.1
Host    img.mukewang.com
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept    image/webp,image/*,*/*;q=0.8
Referer    http://www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8
```

- 第一行为请求行。

- 第二行到最后都是请求头部。

  ​	host指出请求目的地。

  ​	User-Agent,用户代理，浏览器和服务器都能访问，是一种向访问网站提供你所使用的浏览器类型、[操作系统](http://lib.csdn.net/base/operatingsystem)及版本、CPU 类型、浏览器渲染引擎、浏览器语言、浏览器插件等信息的标识。

- 这里请求数据为空，这样的话也要有请求数据上面的空行

post请求例子：

```http
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

这里比上面多了第四部分请求数据，注意上面的空行



#### 服务器的响应消息 response 

**状态行response line, header,空行，body**

![](http://claymore.wang:5000/uploads/big/4acdeb618d8c1814e5aa3bce8487db26.png)

eg:

```http
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

- 第一行，状态协议，状态码，状态消息

- 第二，三行 指定客户端使用的一些附加消息。

  Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8

- 第三部分，空行，跟在消息报头的后面是必须的。

- 第四部分，响应正文，服务器返回给客户端的文本信息。

#### 状态码

- 成功2××          成功处理了请求的状态码。
  - 200                   服务器已成功处理了请求并提供了请求的网页。
  - 201                   请求成功，一个新的资源已经在服务端创建。
  - 204                   服务器成功处理了请求，但没有返回任何内容。                         
- 重定向3××       每次请求中使用重定向不要超过 5 次。
  - 301                   请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。
  - 302                   请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。
  - 304                   如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。
- 客户端错误4××  表示请求可能出错，妨碍了服务器的处理。
  - 400                    服务器不理解请求的语法。
  - 401                    未授权，客户端没有被认证，请求资源前先认证。
  - 403                    服务器拒绝请求，客户端没有权限访问资源，但是客户端已经认证。
  - 404                    服务器找不到请求的网页。服务器上不存在的网页经常会返回此代码。
  - 405                    所使用的http请求方法在该URL不可用。
  - 410                    请求的资源永久删除后，服务器返回此响应。该代码    
  - 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时用来替代404 代码。如果资源已永久删除，应当使用 301 指定资源的新位置。
- 服务器错误5××   表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。
  - 500                     服务器遇到错误，无法完成请求。
  - 503                     服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。    



### 串行，持久，管道化持久，多路复用

**串行连接：** HTTP有无连接的特性，即每次连接只能处理一个请求，收到响应后立即断开连接。HTTP/1.0 版本（称为串行连接或短连接、短轮询）中每次HTTP通信后都要断开TCP连接，所以每个新的HTTP请求都需要建立一个新的连接。但在现在网站动则几十条HTTP请求的情况下，很容易达到浏览器请求上限，并且每次请求都建立新的tcp连接（每次都有三次握手四次挥别）极大的增加了通信开销。

**持久连接：** 为解决这个问题，有人提出了持久连接（也叫长连接、长轮询）。一定时间内，同一域名下的HTTP请求，只要两端都没有提出断开连接，则持久保持TCP连接状态，其他请求可以复用这个连接通道。HTTP/1.1 实现并默认了所有连接都是持久连接，这样客户端发起多个HTTP请求时就减少了TCP握手造成的网络资源和通信时间的浪费。但是持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着（就是常说的线头阻塞）。

**管道化持久连接：** 管道化则可以不用等待响应返回而发送下个请求并按顺序返回响应，现代浏览器并未默认开启管道化

**HTTP/2.0多路复用：** 每个HTTP请求都有一个序列标识符，这样浏览器可以并发多个请求，服务器接收到数据后，再根据序列标识符重新排序成不同的请求报文，而不会导致数据错乱（ [细节参照此文](https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fq%2F1010000005167289)）。同样，服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文。并且同一个域名下的所有请求都复用同一个TCP连接，极大增加了服务器处理并发的上限。

**WebSocket：** WebSocket是HTML5提出的一种客户端和服务端通讯的双全工协议，由客户端发起请求，建立连接之后不仅客户端可以主动向服务端发送请求，服务端可以主动向客户端推送信息。

![](http://claymore.wang:5000/uploads/big/60c543af5c5486a9ace2ea12e67369cb.png)

如图中(a)：串行连接每次发起请求都必须建立新的tcp连接。

如图中(b)：持久连接多个http请求可以复用同一个tcp连接，但是下次请求必须在上次响应返回之后进行。

如图中(c)：管道化持久连接也可以复用同一个tcp连接，并且可以不用等待发出多个http请求，但是响应必须按顺序返回。



### http 版本

#### HTTP/1.0

最早的http只是使用在一些较为简单的网页上和网络请求上，所以比较简单，每次请求都打开一个新的TCP链接，收到响应之后立即断开连接。

#### HTTP/1.1

- HTTP/1.1 引入了更多的缓存控制策略，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等
- HTTP/1.1 允许范围请求，几在请求头中加入`Range`头部
- HTTP/1.1 的请求消息和响应消息都必须包含`Host`头部，以区分同一个物理主机中的不同虚拟主机的域名
- HTTP/1.1 默认开启持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。

#### HTTP/2.0

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表传输的最小的数据单位，每个帧都有序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。

- **新的二进制格式：** HTTP/1.x的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景必然很多。二进制则不同，只识别0和1的组合。基于这种考虑HTTP/2.0的协议解析采用二进制格式，方便且强大。
- **多路复用：** HTTP/2.0支持多路复用，这是HTTP/1.1持久连接的升级版。多路复用，就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求/响应，对应端可以通过帧中的标识知道属于哪个请求/响应，通过重新排序还原请求/响应。多路复用允许并发的发起多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了线头阻塞问题。这样某个请求任务耗时严重，不会影响到其它连接的正常执行,极大的提高传输性能。
- **头部压缩：** HTTP/1.x的请求和响应头部带有大量信息，而且每次请求都要重复发送，HTTP/2.0使用encoder来减少需要传输的头部大小，通讯双方各自cache一份头部 fields表，既避免了重复头部的传输，又减小了需要传输的大小。
- **服务端推送：** 服务端推送就是把客户端所需要的css/js/img资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤（从缓存中取）。

#### HTTP/3.0

HTTP/2.0 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。反而对于 HTTP/1.0 来说，可以开启多个 TCP 连接，出现丢包反倒只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。 出现这个原因是因为底层TCP协议导致的问题，但是修改TCP协议是不现实的问题。既然不能修改你，就新起一个协议取代你。Google 基于 UDP 协议推出了一个的 QUIC 协议，并且使用在了 HTTP/3 上。

QUIC 基于 UDP，但是UDP本书存在不稳定性等诸多问题，所以QUIC在UDP的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。优点诸多：

*  **避免包阻塞：** 多个数据在TCP连接上传输时，若一个数据包出现问题，TCP需要等待该包重传后，才能继续传输其它数据包。但在QUIC中，因为其基于UDP协议，UDP数据包在出问题需要重传时，并不会对其他数据包传输产生影响。

- **快速重启会话：** 普通基于tcp的连接，是基于两端的ip和端口和协议来建立的。在网络切换场景，例如手机端切换了无线网，使用4G网络，会改变本身的ip，这就导致tcp连接必须重新创建。而QUIC协议使用特有的UUID来标记每一次连接，在网络环境发生变化的时候，只要UUID不变，就能不需要握手，继续传输数据。













