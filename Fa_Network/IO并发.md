### 高并发是什么

`高并发`的基本表现为单位时间内系统能够同时处理的请求数,
`高并发`的核心是对CPU资源的**有效压榨**。

和并行的区别：

**并行：两个事件同一时刻完成。**
**并发：两个事件在同一时间段内交替发生,从宏观上看，两个事件都发生了**。

**对于大多数互联网应用来说,CPU不是也不应该是系统的瓶颈，系统的大部分时间的状况都是CPU在等I/O (硬盘/内存/网络) 的读/写操作完成。**

这个时候就可能有人会说，我看系统监控的时候，内存和网络都很正常，但是CPU利用率却跑满了这是为什么？



### 上下文

一个线程在占用CPU资源的。因此，Linux作为一个多任务(进程)系统，会频繁的发生进程/线程切换。

在每个任务运行前，CPU都需要知道从哪里加载，从哪里运行，这些信息保存在`CPU寄存器`和操作系统的`程序计数器`里面，这两样东西就叫做 `CPU上下文`。
进程是由内核来管理和调度的，进程的切换只能发生在内核态，因此 虚拟内存、栈、全局变量等用户空间的资源，以及内核堆栈、寄存器等内核空间的状态,就叫做 `进程上下文`。
前面说过,线程是操作系统调度的最小单位。同时线程会共享父进程的虚拟内存和全局变量等资源，因此 父进程的资源加上线上自己的私有数据就叫做`线程的上下文`。

对于线程的上下文切换来说，如果是同一进程的线程，因为有资源共享，所以会比多进程间的切换消耗更少的资源。

现在就更容易解释了，进程和线程的切换，会产生`CPU上下文`切换和`进程/线程上下文`的切换。而这些`上下文切换`,都是会消耗额外的CPU的资源的。

- 进一步谈谈协程的上下文切换

那么协程就不需要上下文切换了吗？需要，但是**不会产生** `CPU上下文切换`和`进程/线程上下文`的切换,因为这些切换都是在同一个线程中，即用户态中的切换，**你甚至可以简单的理解为**，`协程上下文`之间的切换，就是移动了一下你程序里面的指针，CPU资源依旧属于当前线程。

最终的效果就是协程**进一步压榨了CPU的有效利用率**。

**无论用什么编程语言，只要针对CPU利用率做有效的优化(连接池、守护进程、多线程、协程、select轮询、epoll事件驱动)，你也能搭建出一个高并发和高性能的系统。**



### CPU密集和IO密集

CPU密集型程序，多线程跑的时候，可以充分利用起所有的cpu核心，比如说4个核心的cpu,开4个线程的时候，可以同时跑4个线程的运算任务，此时是最大效率。

但是如果线程远远超出cpu核心数量 反而会使得任务效率下降，因为频繁的切换线程也是要消耗时间的。

因此对于cpu密集型的任务来说，线程数等于cpu数是最好的了。

正常来说，一个线程或进程只能在一个核上，多核或多cpu是可以真正并行多进程或线程的。

对于Python如果是CPU密集型应该用多进程模型（大量的计算）

如果是IO密集型应该用多线程模型（数据的读取写入、网络IO数据传输）

　　由于GIL的存在，CPython不能有效的利用多核处理器，表现为任意时间一个进程只有一个线程在跑；而IO密集型运算，多数是在IO读写将线程堵塞掉了，这个时候线程切换是很合理的，反正线程只是单纯地等待，在这个等待的时候去做其他的事情，资源利用率就上去了。　　

　python的多线程只能使用一个cpu核心，io密集型应用，本来cpu占用率就很低（主要原因还是GIL锁）

　python多线程这个限制和协程有点像，应用也很像，都是适合io密集型