## 引用类型

引用类型 reference type 特指 slice，map， channel这三种预定义类型。

相比数字，数组等类型， 引用类型拥有更复杂的存储结构。

除了分配内存外，还要初始化一系列属性，诸如指针，长度，甚至哈希分布，数据队列等。



### new 和 make

new  按指定类型长度分配零值内存，返回指针， 不关心类型内部构造和初始值。

make ， 引用类型必须使用 make函数创建， 编译器会将make转换为目标类型专用的创建函数（或指令）， 以确保完成全部内存分配和相关属性初始化。

make函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。



### slice切片

#### 结构

![](https://github.com/ClayAndMore/MyImage/blob/master/go/go%20slice.png?raw=true)

```go
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```

上图中一个切片变量包含三个域，分别是底层数组的指针、切片的长度 length 和切片的容量 capacity。

切片支持 append 操作可以将新的内容追加到底层数组，也就是填充上面的灰色格子。

如果格子满了，切片就需要扩容，底层的数组就会更换。

切片本身是个只读对象，工作机制类似数组指针的一种包装。



#### 创建和初始化

引用类型须使用make函数**或**显式初始化语句，会自动完成底层数组内存分配

```go
s1 := make([]int, 3, 5)   // 指定 len, cap
s2 := make([]int, 3)      // 省略了cap, 和 len 相等
s3 := []int{10,20,5: 30}

fmt.Println(s1, len(s1), cap(s1))  // [0,0,0], 3 5
fmt.Println(s2, len(s2), cap(s2))  // [0,0,0], 3 3
fmt.Println(s3, len(s3), cap(s3))  // [10,20,0,0,0,30] 6 6
```



几点注意：

* 不支持比较操作， 就算元素类型相同也不行， 仅能判断是不是nil



#### 切片的赋值

切片的赋值是一次浅拷贝操作，拷贝的是切片变量的三个域，你可以将切片变量看成长度为 3 的 int 型数组，数组的赋值就是浅拷贝。拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。

```go
import "fmt"

func main() {
 var s1 = make([]int, 5, 8)
 // 切片的访问和数组差不多
 for i := 0; i < len(s1); i++ {
  s1[i] = i + 1
 }
 var s2 = s1
 fmt.Println(s1, len(s1), cap(s1))
 fmt.Println(s2, len(s2), cap(s2))

 // 尝试修改切片内容
 s2[0] = 255
 fmt.Println(s1)
 fmt.Println(s2)
}

--------
[1 2 3 4 5] 5 8
[1 2 3 4 5] 5 8
[255 2 3 4 5]
[255 2 3 4 5]
```



#### 遍历

```go
package main

import "fmt"

func main() {
    var s = []int{1,2,3,4,5}
    for index := range s {
        fmt.Println(index, s[index])
    }
    for index, value := range s {
        fmt.Println(index, value)
    }
}

--------
0 1
1 2
2 3
3 4
4 5
0 1
1 2
2 3
3 4
4 5
```





#### reslice

切片的切片



#### append

向切片尾部添加数据， 返回新的切片对象,**但地址还在原数组范围之内**。

```go
s := make([]int, 0, 5)
s1 := append(s, 10)
s2 := append(s1, 20, 30) 
fmt.Println(s, len(s), cap(s))   // []   0 5
fmt.Println(s1, len(s1), cap(s1))// [10] 1 5
fmt.Println(s2, len(s2), cap(s2))// [10 20 30] 3 5
```

S2， 为新变量，和s1共享同一个数组。

这时，切片变量的三个部分都是不变的。

上面这种情况，**底层数组是共享的，一个切片的内容变化就会影响到另一个切片**

so: 

* 对数组进行切割可以转换成切片，切片将原数组作为内部底层数组。
* 也就是说修改了原数组会影响到新切片，对切片的修改也会影响到原数组。

如果超出cap限制， 则为新切片重新分配数组。进行扩容

```go
s1 := make([]int, 0, 5)
s2 := append(s1, 1,2,3,4,5,6) // s2已经不和s1共享一个地址范围内。底层数组会分离，不共享。
fmt.Println(s2, len(s2), cap(s2))// [1,2,3,4,5,6] 6 10
```

当比较短的切片扩容时，系统会多分配 100% 的空间，也就是说分配的数组容量是切片长度的2倍。但切片长度超过1024时，扩容策略调整为多分配 25% 的空间，这是为了避免空间的过多浪费。



#### 切割

切片的切割可以类比字符串的子串，它并不是要把切片割断，而是从母切片中拷贝出一个子切片来，子切片和母切片共享底层数组。

```go
package main

import "fmt"

func main() {
 var s1 = []int{1,2,3,4,5,6,7}
 // start_index 和 end_index，不包含 end_index
 // [start_index, end_index)
 var s2 = s1[2:5] 
 fmt.Println(s1, len(s1), cap(s1))
 fmt.Println(s2, len(s2), cap(s2))
}

------------
[1 2 3 4 5 6 7] 7 7
[3 4 5] 3 5
```



![](https://github.com/ClayAndMore/MyImage/blob/master/go/go%20slice%20%E5%88%86%E5%89%B2.png?raw=true)

子切片的容量是子切片末尾到母切片开始的长度。



和python的切片类似, 但不支持负数

```go
x := [...]int{0,1,2,3,4,5,6,7,8,9}
x[:] = [0,1,2,3,4,5,6,7,8,9]
x[2:5] = [2,3,4]
x[2:5:7] = [2,3,4]  // 7指的是所引用的数组片段真实长度（7-2）, len是限定可读写的元素数量（5-2）
```



#### copy

Go 语言还内置了一个 copy 函数，用来进行切片的深拷贝。不过其实也没那么深，只是深到底层的数组而已。如果数组里面装的是指针，比如` []*int `类型，那么指针指向的内容还是共享的。

`func copy(dst, src []T) int`

copy 函数不会因为原切片和目标切片的长度问题而额外分配底层数组的内存，它只负责拷贝数组的内容，从原切片拷贝到目标切片，拷贝的量是原切片和目标切片长度的较小值 —— min(len(src), len(dst))，函数返回的是拷贝的实际长度

```go
package main

import "fmt"

func main() {
 var s = make([]int, 5, 8)
 for i:=0;i<len(s);i++ {
  s[i] = i+1
 }
 fmt.Println(s)
 var d = make([]int, 2, 6)
 var n = copy(d, s)
 fmt.Println(n, d)
}
-----------
[1 2 3 4 5]
2 [1 2]
```





### map 字典

无序键值对集合， 使用make函数或初始化表达语句来创建

```go
func main(){
    m := make(map([string]int))
    m["a"] = 1
    m["b"] = 2
    // 如果你可以预知字典内部键值对的数量，那么还可以给 make 函数传递一个整数值，通知运行时提前分配好相应的内存。这样可以避免字典在长大的过程中要经历的多次扩容操作。
    var m = make(map[int]string, 16)
    
    // 值为匿名结构类型
    m2 := map[int]struct {
        x int
    }{
        1: {x: 100},
        2: {x: 200},
    }
    
    var m map[int]string = map[int]string{ //var m = map[int]string{
        90: "优秀",
        80: "良好",
        60: "及格",  // 注意这里逗号不可缺少，否则会报语法错误
    }
}
```



#### 基本操作

```go
score = fruits["banana"] //读取
m["a"] = 10 // 修改
m["c"] = 20 // 新增
if v, ok := m["d"]; ok{  // 使用ok-idiom判断key是否存在，不存在默认返回零值。
    println(v)
}

delete(m, "d")  //删除键值对，不存在时， 不会报错

// len 返回键值对数量， cap不接受字典
```



不存在：

读操作时，如果 key 不存在，也不会抛出异常。

它会返回 value 类型对应的零值。如果是字符串，对应的零值是空串，如果是整数，对应的零值是 0，如果是布尔型，对应的零值是 false。

因为当value为0时， 你也不知道存不存在。

推荐使用ok-idiom，字典的下标读取可以返回两个值，使用第二个返回值都表示对应的 key 是否存在。

```go
var score, ok = fruits["durin"]
    if ok {
        fmt.Println(score)
    } else {
        fmt.Println("durin not exists")
    }
```





#### 迭代：

字典的遍历提供了下面两种方式，一种是需要携带 value，另一种是只需要 key，需要使用到 Go 语言的 range 关键字。

```go
package main
import "fmt"

func main() {
    var fruits = map[string]int {
        "apple": 2,
        "banana": 5,
        "orange": 8,
    }

    for name, score := range fruits {
        // 遍历的时候，直接得到的value是拷贝过后的，会影响性能，如果在遍历中，
        // ·使用map[key] 的方式可以直接用索引获取数据，速度要比使用value快近一倍，当然要考虑指针安全的问题
        fmt.Println(name, score)
    }

    for name := range fruits {
        fmt.Println(name)
    }
}

------------
orange 8
apple 2
banana 5
apple
banana
orange
```

奇怪的是，Go 语言的字典没有提供诸于 keys() 和 values() 这样的方法，意味着如果你要获取 key 列表，就得自己循环一下，如下：

```go
package main
import "fmt"

func main() {
    var fruits = map[string]int {
        "apple": 2,
        "banana": 5,
        "orange": 8,
    }

    var names = make([]string, 0, len(fruits))
    var scores = make([]int, 0, len(fruits))

    for name, score := range fruits {
        names = append(names, name)
        scores = append(scores, score)
    }

    fmt.Println(names, scores)
}

----------
[apple banana orange] [2 5 8]
```





#### not addressable

```go
type user struct {
    name string
    age btye
}
m := map[int]user{
    1: {"Tom", 19}
}
m[1].age += 1 // error: cannot assign to m[1].age
```

因访问安全和哈希算法等缘故，不能直接修改value成员（结构或数组）

正确做法：

```go
u := m[1]
u.age += 1
m[1] = u
```

指针类型：

```go
m2 := map[int]*user{
    1: &user("Jack", 20),
}
m2[1].age++     // m2[1] 返回的是指针，可以通过指针修改目标对象
```



#### nil 字典

不能对nil字典进行写操作， 但却能读。

```go
var m map[string]int
println(m["a"]) //返回零值
m["a"] = 1 //panic: assignment to entry in nil map
```

内容为空的字典，与nil是不同的

```go
var m1 map[string]int  // nil
m2 : map[string]int()  // 已初始化，等同make操作, !=nil
```



#### 线程（协程）安全

go 语言的内置字典不是线程安全的，如果需要线程安全，必须使用锁来控制。后续。



### channel

