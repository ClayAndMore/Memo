## 引用类型

引用类型 reference type 特指 slice，map， channel这三种预定义类型。

相比数字，数组等类型， 引用类型拥有更复杂的存储结构。

除了分配内存外，还要初始化一系列属性，诸如指针，长度，甚至哈希分布，数据队列等。



### new 和 make

new  按指定类型长度分配零值内存，返回指针， 不关心类型内部构造和初始值。

make ， 引用类型必须使用 make函数创建， 编译器会将make转换为目标类型专用的创建函数（或指令）， 以确保完成全部内存分配和相关属性初始化。

make函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。



### slice切片

```go
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```

切片本身是个只读对象，工作机制类似数组指针的一种包装。

和python的切片类似

```go
x := [...]int{0,1,2,3,4,5,6,7,8,9}
x[:] = [0,1,2,3,4,5,6,7,8,9]
x[2:5] = [2,3,4]
x[2:5:7] = [2,3,4]  // 7指的是所引用的数组片段真实长度（7-2）, len是限定可读写的元素数量（5-2）
```

引用类型须使用make函数**或**显式初始化语句，会自动完成底层数组内存分配

```go
s1 := make([]int, 3, 5)   // 指定 len, cap
s2 := make([]int, 3)      // 省略了cap, 和 len 相等
s3 := []int{10,20,5: 30}

fmt.Println(s1, len(s1), cap(s1))  // [0,0,0], 3 5
fmt.Println(s2, len(s2), cap(s2))  // [0,0,0], 3 3
fmt.Println(s3, len(s3), cap(s3))  // [10,20,0,0,0,30] 6 6
```



几点注意：

* 不支持比较操作， 就算元素类型相同也不行， 仅能判断是不是nil



#### reslice

切片的切片



#### append

向切片尾部添加数据， 返回新的切片对象,**但地址还在原数组范围之内**

```go
s := make([]int, 0, 5)
s1 := append(s, 10)
s2 := append(s1, 20, 30) 
fmt.Println(s, len(s), cap(s))   // []   0 5
fmt.Println(s1, len(s1), cap(s1))// [10] 1 5
fmt.Println(s2, len(s2), cap(s2))// [10 20 30] 3 5
```

如果超出cap限制， 则为新切片重新分配数组。

```go
s := make([]int, 0, 100)
s1 := s[:2:4] // 只有4cap
s2 := append(s1, 1,2,3,4,5,6) // s2已经不和s1共享一个地址范围内。
```



#### copy



### map 字典

无序键值对集合， 使用make函数或初始化表达语句来创建

```go
func main(){
    m := make(map([string]int))
    m["a"] = 1
    m["b"] = 2
    
    // 值为匿名结构类型
    m2 := map[int]struct {
        x int
    }{
        1: {x: 100},
        2: {x: 200},
    }
}
```



#### 基本操作

```go
m["a"] = 10 // 修改
m["c"] = 20 // 新增
if v, ok := m["d"]; ok{  // 使用ok-idiom判断key是否存在，不存在默认返回零值。
    println(v)
}

delete(m, "d")  //删除键值对，不存在时， 不和报错

// len 返回键值对数量， cap不接受字典
```

推荐使用ok-idiom， 其他方式当value为0时， 你也不知道存不存在。

#### 迭代：

```go
m := make(map[string]int)

for i :=0; i<8; i++ {
    m[string('a'+i)] = i
}

for i := 0; i<4; i++ {
    for k, v := range m {
        print(k, ":", v, " ")
    }
    println()
}
```

out:

`h: 7   a: 0   b: 1   c:2   d:3  e: 4    f:5   g:6 `



#### not addressable

```go
type user struct {
    name string
    age btye
}
m := map[int]user{
    1: {"Tom", 19}
}
m[1].age += 1 // error: cannot assign to m[1].age
```

因访问安全和哈希算法等缘故，不能直接修改value成员（结构或数组）

正确做法：

```go
u := m[1]
u.age += 1
m[1] = u
```

指针类型：

```go
m2 := map[int]*user{
    1: &user("Jack", 20),
}
m2[1].age++     // m2[1] 返回的是指针，可以通过指针修改目标对象
```



#### nil 字典

不能对nil字典进行写操作， 但却能读。

```go
var m map[string]int
println(m["a"]) //返回零值
m["a"] = 1 //panic: assignment to entry in nil map
```

内容为空的字典，与nil是不同的

```go
var m1 map[string]int  // nil
m2 : map[string]int()  // 已初始化，等同make操作, !=nil
```





### channel

