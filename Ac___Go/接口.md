## 接口

接口代表一种调用契约，是过个方法声明的集合。

Go实现接口的机制很简单，只要目标方法集内包含接口声明的全部方法，就被视为实现了该接口。

* 不能有字段
* 不能有自己定义的方法
* 只能声明方法，不能实现
* 可以嵌入其他接口类型

```go
type tester interface{
    test()
    string() string
}

type data struct{}

func (*data) test(){}
func (data) string() string {return ""}

func main(){
    var d data
}
```



Go 语言的接口是隐式的，只要结构体上定义的方法在形式上（名称、参数和返回值）和接口定义的一样，那么这个结构体就自动实现了这个接口，我们就可以使用这个接口变量来指向这个结构体对象。

```go
package main
import "fmt"

// 可以闻
type Smellable interface {
  smell()
}
// 可以吃
type Eatable interface {
  eat()
}

// 苹果既可能闻又能吃
type Apple struct {}

func (a Apple) smell() {
  fmt.Println("apple can smell")
}

func (a Apple) eat() {
  fmt.Println("apple can eat")
}

// 花只可以闻
type Flower struct {}

func (f Flower) smell() {
  fmt.Println("flower can smell")
}

func main() {
  var s1 Smellable
  var s2 Eatable
  var apple = Apple{}
  var flower = Flower{}
  s1 = apple
  s1.smell()
  s1 = flower
  s1.smell()
  s2 = apple
  s2.eat()
}

--------------------
apple can smell
flower can smell
apple can eat
```



### 接口变量的本质

使用接口时，我们可以将接口看成一个特殊的容器，这个容器只能容纳一个对象，

只有实现了这个接口类型的对象才可以放进去。

![](https://github.com/ClayAndMore/MyImage/blob/master/go/go_interface.png?raw=true)

接口变量也是由结构体来定义的，这个结构体包含两个指针字段，一个字段指向被容纳的对象内存，另一个字段指向一个特殊的结构体 itab，这个特殊的结构体包含了接口的类型信息和被容纳对象的数据类型信息。

```go
// interface structure
type iface struct {
  tab *itab  // 类型指针
  data unsafe.Pointer  // 数据指针
}

type itab struct {
  inter *interfacetype // 接口类型信息
  _type *_type // 数据类型信息
  ...
}
```

