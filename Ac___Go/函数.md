## 函数

**Go是编译型语言，所以函数编写的顺序是无关紧要的；**

* 当函数执行到代码块最后一行（`}` 之前）或者 `return` 语句的时候会退出，其中 `return` 语句可以带有零个或多个参数

* 除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为**函数签名**。

* 大括号有要求， 左花括号不能另起一行：

  这样是不正确的 Go 代码：

  ```
  func g()
  {
  }
  ```

  它必须是这样的：

  ```
  func g() {
  }
  ```

* 函数调用基本格式：`pack1.Function(arg1, arg2, …, argn)`

* 函数判断只支持是否为nil

  ```go
  func a() {}
  func b() {}
  func main() {
      println(a == nil)
      println(a == b) // 错误
  }
  ```



### 参数

比较保守，不支持可选参数，必须按签名顺序传递指定类型和数量的实参，以‘_’命名的参数也不能忽略：

```go
func test(x, y int, s string, _ bool) *int{
    return nil
}
```



不管是指针，引用类型还是其他类型参数，都是值拷贝传递（pass-by-value）

区别无非是拷贝目标对象还是拷贝指针而已。

函数调用前，为形参和返回值分配内存空间，并将实参拷贝到形参内存。

```go
func text(x *int){
    fmt.Printf(&x, x)
}

func main(){
    a := 0x100
    p := &a
    fmt.Printf(&p, p)
    test(p)
}

输出：
0x82002c020 0x82000a298   // 指针地址的地址， 指针地址
0x82002c030 0x82000a298

```



### 返回值

一定有return 语句 。

```go
func test(x int) int {  //int  定义返回值类型
    return 1
}
```

返回多值

```python
import "errors"
func div(x, y int) (int, error) {  //多返回值列表必须使用括号
    if y==0{
        return 0, errors.New("division by zero")
    }
}
```

命名返回值

```go
func div(x, y int) (z int, err error){
    if y==0{
        err = errors.New("divison by zero")
        return
    }
    z=x/y
    return //相当于return z, err
}
```





### 匿名函数

没有定义名字的函数：

```go
func main(){
    func(s string){
      println(s)  
    }("hello world")  //直接执行
    
    add := func(x, y int) int { //赋值给变量
        return x+y
    }
    
    test(func() {
        println("hello world") // 作为参数
    })
    
    func test() func(int,int) int{  
        return func(x,y int) int {   // 作为返回值
            return x+y
        }
    }
    
}
```

不曾使用的匿名函数会被编译器当做错误。



### 闭包





### 延迟调用defer

defer: 向当前函数注册稍后执行的函数调用。**直到当前函数执行结束前才被执行**

常用于资源释放，解除锁定，错误处理。

```go
func main(){
  	f, err := os.Open("./main.go")

	defer f.Close()  
}

----
func main(){
    x,y := 1,2
    defer func(a int){
        println("defer x, y =", a,y)
    }(x)                 // y 为闭包引用。
    
    x += 100             //x的修改不会影响defer
}
```

FILO:

```go
func main(){
    defer println("a")
    defer println("b")
}
输出： 
b
a
```

延迟调用会花费更多开销，应合理使用。



### 错误处理

