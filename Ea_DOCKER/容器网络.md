## 容器网络

网络 虚拟化

### 网络虚拟设备

linux是通过网络设备区操作和使用网卡的，系统装了一个网卡后会为其生成一个网络设备实例，如eth0.

linux也支持创建出虚拟化的设备，主要记录Veth 和 Bridge



#### ip netns

ip命令的netns可以让一台机器上模拟多个网络设备，是网络虚拟化的重要组成，将不同类型的网络应用隔离。

需要内核支持，不然ip 没有netns命令

一个net namespace有自己独立的路由表，iptables策略，设备管理。说来说去，它就是用来隔离的。比如将eth0加入了netns 1，那么netns 2中的应用程序就找不到eth0了。netns 1中的iptables策略，不会去影响netns 2中的iptables策略。

用法：

```
[root@monitor ~]# ip netns help list
Usage: ip netns list
       ip netns add NAME
       ip netns set NAME NETNSID
       ip [-all] netns delete [NAME]
       ip netns identify [PID]
       ip netns pids NAME
       ip [-all] netns exec [NAME] cmd ...
       ip netns monitor
       ip netns list-id
```



* 打开内核的网络转发功能

  ```
  [root@localhost ~]# vim /etc/sysctl.conf 
  [root@localhost ~]# sysctl -p
  net.ipv4.ip_forward = 1
  ```

* 添加两个namespace

  ```
  [root@monitor ~]# ip netns add r1
  [root@monitor ~]# ip netns add r2
  [root@monitor ~]# ip netns list
  r2
  r1
  ```






#### Veth

Veth 是成对出现的虚拟网络设备， 发送到Veth的一端虚拟设备请求会从另一端的虚拟设备发出。

创建两个网络namespace:

```bash
root@:# ip netns add ns1
root@:# ip netns list
ns1
root@# ip netns add ns2
```

创建一对veth

```bash
root@# ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:86:04:2a brd ff:ff:ff:ff:ff:ff
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default
    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff
5: veth9ea5fdd: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 26:dc:7d:94:97:dd brd ff:ff:ff:ff:ff:ff
7: veth5faf20e: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 62:a2:16:40:72:6e brd ff:ff:ff:ff:ff:ff

root@# ip link add veth0 type veth peer name veth1
root@# ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:86:04:2a brd ff:ff:ff:ff:ff:ff
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default
    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff
5: veth9ea5fdd: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 26:dc:7d:94:97:dd brd ff:ff:ff:ff:ff:ff
7: veth5faf20e: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether 62:a2:16:40:72:6e brd ff:ff:ff:ff:ff:ff
8: veth1: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether ba:5f:b9:c5:c3:28 brd ff:ff:ff:ff:ff:ff
9: veth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether c6:85:e2:28:fc:4d brd ff:ff:ff:ff:ff:ff
```
分别将两个veth 移到Namespace中。
```bash
root@:# ip link set veth0 netns ns1
root@:u# ip link set veth1 netns ns2
# 去 ns1 的namespace 中查看网络
root@:# ip netns exec ns1 ip link
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
9: veth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether c6:85:e2:28:fc:4d brd ff:ff:ff:ff:ff:ff
```
可以看到，除了loopback的设备，有个veth0, 当请求 发送到这个虚拟网络时， 都会从另一个网络Namespace 的网络接口中出来。

配置每个veth 的网络地址和路由
```bash
root@:# ip netns exec ns1 ifconfig veth0 172.18.0.2/24 up
root@:# ip netns exec ns2 ifconfig veth1 172.18.0.3/24 up
root@:# ip netns exec ns1 route add default dev veth0
root@:/home/ubuntu# ip netns exec ns2 route add default dev veth1
```
通过veth一端的包，另一端一定能够接收到。
```basj
root@:/home/ubuntu# ip netns exec ns1 ping -c 1 172.18.0.3
PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.
64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.050 ms

--- 172.18.0.3 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.050/0.050/0.050/0.000 ms

```



#### Linux Bridge

Bridge 虚拟设备是用来桥接的网络设备， 它相当于现实世界中的交换机，可以连接不同的网络设备。

当请求到达Bridge设备时， 可以通过报文中的Mac地址进行广播或转发。

eg: 通过创建一个Bridge 设备来连接Namespace 中的网络设备和宿主机上的网络。

```bash
# 创建 veth 设备并将一端移入 Namespace
ip netns add ns1
ip link add veth0 type veth peer name veth1
ip link veth1 setns ns1

# 创建网桥
brctl addbr br0
# 挂载网络设备
brctl addif br0 eth0
brctl addif br0 veth0
```

示意图：

```
主机              __________
                 |    ns1  |
                 |__veth1__|
                      |
____________________veth0____
             br0             |
__eth0_______________________|
```



#### 路由表

路由表是Linux 内核的一个模块， 通过定义路由表来决定在某个网络Namespace中包的流向， 从而定义请求会到哪个网络设备上。

继续用上面的例子演示路由表的功能：

```bash
# 启动虚拟网络设备，并设置它在Net Namespace 中的IP地址。

```

