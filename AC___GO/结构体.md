## struct

将多个不同类型命名字段序列打包成一个复合类型

字段名必须唯一， 可以用“_”补位。

```go
type node struct {
    _  int
    id int
    next *node
}

type user struct {
    name string
    age byte
}

func main(){
    n1 := node{   //命名方式初始化指定字段
        id: 1,
    }
    n2 := node{
        id: 2,
        next: &n1,
    }
    u1 := user{"Tom", 12} // 顺序初始化全部字段
    u2 := user{"Tom"}  // too few values in struct initializer
    
}
```

推荐命名方式初始化指定字段，这样在改变struct顺序时，或调整字段时不会导致初始化语句出错。



### 匿名结构

可以直接定义匿名结构变量类型， 或用作字段类型。但因其缺少类型标识，在作为字段类型时无法直接初始化，稍显麻烦。

```go
func main() {
    u := struct {  // 直接定义匿名结构变量
        name string
        age byte
    }{
        name: "Tom",
        age: 12,
    }
    
    type file struct {
        name string
        attr struct {
            owner int  // 定义匿名结构类型字段
            perm int
        }
    }
    
    f := file{
        name: "test.dat",
        // attr: {
        //		owner: 1,
        //      perm: 0755,
    	//},
    }
    
    f.attr.owner = 1 //正确方式
    f.attr.perm = 0755
}
```



### 相等操作

在所有字段类型全部支持时，才可做相等操作。

```go
func main() {
    type data struct{
        x int
        y map[string]int
    }
    
    d1 := data{
        x:100,
    }
    
    d2 := data{
        x:100,
    }
    println(d1 == d2) //无效操作 struct containing map[string]int cannot be compared
}
```



### 指针操作结构体

可以直接用指针直接操作结构字段， 但不能是多级指针。

```go
func main() {
    type user struct {
        name string
        age int
    }
    p := $user{
        name: "Tom",
        age: 20,
    }
    
    p.name = "Mary"
    p.age++
    
    p2 := $p
    *p2.name = "Jack" // error, p2.name undefined ()
}
```



### 空结构

空结构struct{} 是指没有字段的结构类型，**无论其自身，还是为数组元素类型， 其长度都为零**

```go
func main() {
    var a struct{}
    var b [100]struct{}
    println(unsafe.Sizeof(a), unsafe.Sizeof(b)) //out: 0,0
}

// 没有分配数组内存，但是依然可以操作元素， 对应切片len, cap等属性正常
s := b[:]
b[1] = struct{}{}

fmt.Println(s[3], len(s), cap(s))  //{}, 100, 100

// 实际上， 这类 “长度” 为零的对象通常指向runtime.zerobase变量。
a := [10]struct{}{}
b := a[:]         //底层数组指向 zerobase, 而非 slice
c := [0]int()

fmt.Printf("%p, %p, %p\n", &a[0], %b[0], %c) // 0x19c730, 0x19c730, 0x19c730
```



空结构可用于事件通知，目前还没有看明白：

```go
func main(){
    exit := make(chan struct{})
    
    go func() {
        println("hello, world!")
        exit <-  struct{}{}
    }()
    <-exit
    println("end.")   
}
```



### 匿名字段

anonymous field 是指没有名字，仅有类型的字段，也被称作嵌入字段或嵌入类型。

```go
type file struct {
    name string
    attr // 仅有类型名
}

func main() {
    f := file{
        name: "test.dat"
        attr: attr{     //显式初始化匿名字段
            perm: 0755,
        },
    }
    
    f.perm = 0644		// 直接设置匿名字段成员
    println(f.perm)	    // 直接读取匿名字段成员
}
```



如嵌入其他包中的类型， 则隐式字段名字不包括包名。

```go
type data struct {
    os.File
}

func main() {
    d := data{
        File: os.File{}, //直接File, 没有包名。
    }
}
```



除了接口指针和多级指针以外的任何命名字段类型都可以作为匿名字段。

```go
type data struct{
    *int
    string
}

func main() {
    x := 100
    d := data{
        int: &x,		//使用基础字段作为字段名
        string: "abc",
    }
}

// 不能将基础类型和其他指针类型同时嵌入， 因为两者隐式名字相同
type data struct {
    *int
    int
}
```



虽然可以向普通字段那样访问匿名字段成员， 在嵌套结构下， 访问匿名字段 可能会重名问题。需要显式访问。

```go
type file struct {
    name string
}

type data struct {
    file			//嵌套结构
    name string  	//与 file.name 同名
}

d.name = "data2"		// 访问data.name
d.file.name = "file2" 	// 显式访问data.file.name
```

多个相同层级的匿名字段成员重名：

```go
type file struct{
    name string
}
type log struct {
    name string
}
type data struct {
    file
    log
}

func main() {
    d := data{}
    d.name = "name"    //error, 错误： ambigous selector d.name
    d.file.name = "file"
    d.log.name = "log"
}
```

严格来说， GO并不是传统意义上的面向对象编程语言， 或者说仅仅实现了最小面向对象机制。

匿名嵌入不是继承， 无法实现多态处理。虽然配合方法集， 可以用接口来实现一些类似操作，但本质是完全不同的。



### 字段标签

tag，字段标签并不是注释，而是用来对字段进行描述的元数据。

尽管它不属于数据成员，但确实类型的组成部分。

在运行期，可用于反射获取标签。常被用于格式校验，数据库关系映射等。

```go
type user struct {
    name string `昵称`
    sex byte `性别`
}

func main(){
    u := user{"Tome", 1}
    v := reflect.ValueOf(u)
    t := v.Type()
    
    for i, n := 0, t.NumField(); i<n; i++{
        fmt.Printf("%s: %v\n", t.Field(i).Tag, v.Field(i))
    }
}

out:
昵称：Tom
性别：1
```



### 内存布局

pass