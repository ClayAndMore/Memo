## struct

将多个不同类型命名字段序列打包成一个复合类型

字段名必须唯一， 可以用“_”补位。

```go
type node struct {
    _  int
    id int
    next *node
}

type user struct {
    name string
    age byte
}

func main(){
    n1 := node{   //命名方式初始化指定字段
        id: 1,
    }
    n2 := node{
        id: 2,
        next: &n1,
    }
    u1 := user{"Tom", 12} // 顺序初始化全部字段
    u2 := user{"Tom"}  // too few values in struct initializer
    
}
```

推荐命名方式初始化指定字段，这样在改变struct顺序时，或调整字段时不会导致初始化语句出错。



### 匿名结构

可以直接定义匿名结构变量类型， 或用作字段类型。但因其缺少类型标识，在作为字段类型时无法直接初始化，稍显麻烦。

```go
func main() {
    u := struct {  // 直接定义匿名结构变量
        name string
        age byte
    }{
        name: "Tom",
        age: 12,
    }
    
    type file struct {
        name string
        attr struct {
            owner int  // 定义匿名结构类型字段
            perm int
        }
    }
    
    f := file{
        name: "test.dat",
        // attr: {
        //		owner: 1,
        //      perm: 0755,
    	//},
    }
    
    f.attr.owner = 1 //正确方式
    f.attr.perm = 0755
}
```



### 相等操作

在所有字段类型全部支持时，才可做相等操作。

```go
func main() {
    type data struct{
        x int
        y map[string]int
    }
    
    d1 := data{
        x:100,
    }
    
    d2 := data{
        x:100,
    }
    println(d1 == d2) //无效操作 struct containing map[string]int cannot be compared
}
```



### 指针操作结构体

可以直接用指针直接操作结构字段， 但不能是多级指针。

```go
func main() {
    type user struct {
        name string
        age int
    }
    p := $user{
        name: "Tom",
        age: 20,
    }
    
    p.name = "Mary"
    p.age++
    
    p2 := $p
    *p2.name = "Jack" // error, p2.name undefined ()
}
```



### 空结构

空结构struct{} 是指没有字段的结构类型，**无论其自身，还是为数组元素类型， 其长度都为零**

```go
func main() {
    var a struct{}
    var b [100]struct{}
    println(unsafe.Sizeof(a), unsafe.Sizeof(b)) //out: 0,0
}

// 没有分配数组内存，但是依然可以操作元素， 对应切片len, cap等属性正常
s := b[:]
b[1] = struct{}{}

fmt.Println(s[3], len(s), cap(s))  //{}, 100, 100

// 实际上， 这类 “长度” 为零的对象通常指向runtime.zerobase变量。
a := [10]struct{}{}
b := a[:]         //底层数组指向 zerobase, 而非 slice
c := [0]int()

fmt.Printf("%p, %p, %p\n", &a[0], %b[0], %c) // 0x19c730, 0x19c730, 0x19c730
```



