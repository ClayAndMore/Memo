## 索引



### 创建

`db.users.ensureIndex({"username": 1})`

1 升序，从最小到最大， -1降序。

创建索引根据机器性能需要几分钟时间， 可以在另一个shell中db.currentOp()或者检查mongod日志来查看索引创建进度。

对于每添加一个索引，每次写操作（插入，更新，删除）都会消耗更多时间，因为没更新一个文档还要更新文档的所有索引。

索引值是按照一定顺序排列的，所以使用索引键对文档排序非常快，如果按照索引查询， 查询结果则是按照索引顺序排列的，可以不用再排列。



### 复合索引

`db.user.ensureIndex({"age": 1, "username": 1})`

索引先按age排序，相同age再按username排序。索引大概是这个样子：

```
[15, user1003] -> 0xOc965234 // 年龄， 用户，-> 硬盘wwv
[15, user1004] -> 0xOc933d34
[15, user1014] -> 0xOc965234
...
[60, user8992] -> 0xOc96d234
```

三种对上述索引的主要操作：

```js
1. 单值操作
db.users.find({"age": 21}).sort({"username": -1}) 
// 由于username在21处已经排序，所以只需要从后往前反数据就可以, 上述是一个高效操作。
2. 多值查询
db.users.find({"age": {"$gte": 21, "$lte": 30}}))
// 会使用第一个索引键来查询，没什么问题
3. 排序的多值查询
db.users.find({"age": {"$gte": 21, "$lte": 30}}).sort({"username":1})
//username此时并不是有序的,因为有多个age, 会在内存中排序再返回，没有上面高效

上面的使用的索引是{"age": 1, "username": 1}， 针对第三种我们使用相反的索引：｛"username": 1，"age": 1｝会怎么样呢？

相反的索引会在以username为顺序逐项检查符合age的条件，会遍历一遍所有， 但是遍历后结果不用再排序。

```

针对上面的情况，我们可以强制使用特定的索引： hint

```js
db.user.find({"age": {"$gte": 21, "$lte": 30}})
    .sort({"username":1})
	.hint({"username": 1, "age":1}) //强制使用索引

这样查会很慢很慢， 如果情况3花费3s， 上面的情况可能会有15s.
但是如果加上limit限制，比如后面都加上limit(1000), 新的赢家就产生了：
如情况3花费2s, 那么加上限制的上面只有不到1/5s.
```



#### 覆盖索引

如果查询只需要返回索引中的字段，没有必要返回文档。



#### 隐式索引

```
{"age": 1, "username": 1} 索引， age字段会字段排序， 可以和{"age": 1}索引一样使用

如果我有{"a":1, "b":1, "c":1, "d":1, "e":1} 索引， 那么我可以使用{"a": 1, "b": 1},{"a":1,"b":1,"c":1}等索引。
但是不能使用{"a":1, "c":1}
```

**只有使用索引前缀的查询才可以从中受益**



### 操作符中使用索引

#### 低效率的操作符

`$where` 和 `$exists` 完全无法使用索引，

`$ne` 可以使用索引，但不是很高效

`$not`, 大多数not会退化为全表扫描。



#### 范围

如 gt, lt等范围操作符，

针对于复合索引来说， 将索引前缀用于精确匹配，后面用于范围，如：

```
索引： {"age": 1, "username": 1}
db.users.find({"age": 47, "username": {"$gt": "user5", "$lt": "user8"}})
```

如果索引反过来，那么，会糟糕一些，遍历索引条目会多一些。



####  OR

Mongo只能在一次查询中使用一个索引， 如果你在{"x": 1} 和 {"y":1}上都有索引， 在{"x": 123, "y":342}上搜索时会使用一个索引，但是or是个例外，可以对每个子句使用各自的索引，它本质是两次查询结果的合集。

`db.foo.find({"$or": [{"x":123, {"y": 456}}]}`)

但是通常来说，两次的结果不如用一次in的效率高。



### 索引对象和数组

mongo准许在文档内部做索引，如字典和数组

#### 内嵌文档

```js
{
    username: sid
    loc: {
        ip: 1,1,1,1
        city:: beijing
    }
}

db.users.ensureIndex({"loc.city": 1})
```

对于loc建索引和loc.city索引的效果是不同的，对子文档建索引只会提高子文档的速度。

#### 数组

```
{
    username: sid
    loc: {
    	[
         	ip: 1,1,1,1,
        	city:: beijing 
    	],
    	[
         	ip: 1,1,1,1,
        	city:: tianjing 
    	]
    }
}
```

