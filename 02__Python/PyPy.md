Tags:[python]

## PyPy

### 安装

可以去官网，下载压缩包安装。或者：

* centos: `yum install pypy-libs pypy pypy-devel`
* ubuntu: `apt-get install pypy pypy-dev`

经测试，ubuntu 会默认安装到/usr/lib/pypy ,  /usr/lib/pypy/bin/pypy-c 为实际执行文件。




## origin to know
#### 编译型 or 解释型

* 编译： 源代码 - > 可执行文件（一串直接被计算机执行机器指令集）

  优点：一次编译，多次执行，运行效率高。

  缺点： 可移植性差，不同平台的CPU指令集不兼容。，编译耗时和程序规模成正比。

  如c/c++

* 解释： 源代码-> 中间码  

  先翻译成中间码，再由语言提供的解释器逐条解释执行。边解释，边执行。

  优点： 由于解释器的存在，可以跨平台。

  缺点： 效率低。

  python因为含有解释器，常常被归类于解释型语言，这样来说是不严谨的， 

  **python自身也包含了编译器， 它先将源代码编译成中间状态的字节码，再由解释器解释。**

  默认这字节码保存在pyc中，目的是提升运行效率。

  如： java和python


#### 动态 or 静态

**动态、静态指的是编程语言类型系统对数据类型检查的严格程度**

* 静态： 在程序编译时就要确定所有变量的数据类型。要求在使用变量时就实现声明变量的数据类型。

  这样能开发出更复杂庞大的系统，具有更好的代码感知能力，如java,c

* 动态： 一个变量可以在不同位置被赋予各种数据类型，数据类型在运行时才被确定。

  开发效率高，但解释器需要推断变量的类型，一定程度上影响了运行效率。python

#### 强类型 or 弱类型

**强、弱类型指的是编译程序时能否容忍隐式的类型转换**。

* 弱类型在程序运行时可以容忍隐式转换，弱类型是类型非安全的如：js：

  ```
  > '1'+2
  '12'
  ```

* 强类型一旦类型确定，除非强制转换，否侧永远不会改变。如python

强类型在速度上会稍逊于弱类型语言，但是强类型带来的严谨性可以避免很多错误。



### JIT

Just in-time compile  

又译即时编译、实时编译，动态编译的一种形式，是一种提高程序运行效率的方法。

通常，程序有两种运行方式：静态编译与动态直译。

静态编译的程序在执行前全部被翻译为机器码，而直译执行的则是一句一句边运行边翻译。

即时编译器则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码，即时编译的代码可以处理延迟绑定并增强安全性。

即时编译器有两种类型，一是字节码翻译，二是动态编译翻译。

静态编译优化和动态编译优化最大的不同是他们在编译时所得到的信息量的不同。静态编译在运行程序之前就把所有的执行代码编译完，这时编译器所接受的编译信息量是不够多的。比如说：某个函数是否是大量地被调用了，函数的实参是不是一直是一个常数，等等。 

动态编译之于静态编译，缺点是它需要即时编译代码，但是有一个优点---编译器可以获得静态编译期所没有的信息。比如：通过运行时的profiling可以知道哪些函数是被大量使用的。在哪些execution path上哪些函数的参数一直都没有变，等等。不要小看这些信息，当即时编译器了解这些信息之后可以在短时间内编译出比静态编译器更优质的二进制码。举例来说，一般程序也遵循90-10原则，即运行时的90%里计算机是在处理其中10%的代码，寻找到这些执行热点代码进行深度优化能得到比静态编译更好的性能（因为已知更多信息量）。  

然而现实是：即时编译的开销非常大，暂时还不能超越静态编译的总体性能。不过，一个动态语言（Python）有着静态语言（如C++）所没有的各种优势，必然是将来程序语言发展的方向。伴随着强大的需求，即时编译器在将来也会更加强大。



#### JIT的优缺点

以Java/C#,NET为代表的语言，是建立在虚拟机之上的。
这种虚拟机和一般其他语言的运行库有一个很大不同，就是它好像一个有独立体系结构的计算机。 
Java/C#,NET的程序要运行在这些虚拟机之上，**就必须要编译成虚拟机独有的中间语言。**

Java叫字节码，C#,NET有很多种叫法，姑且简称CIL。这些中间语言身上有很深很深的汇编指令集样式语法痕迹，这也从 另一个侧面说明虚拟机的体系结构多么像一个冯诺依曼计算机。
**虚拟机传统的解释器，就是要在中间语言，和真正的平台体系结构之间的指令做映射。**比如把Java的load指令换成native code 的load指令。

JIT的出现，是为了补强虚拟机边运行边解释的低性能。它会智能地对热点代码进行优化且重复利用。

**从策略的角度来讲，就是通过查表或者缓存而不是重复解决子问题而大大缩短解决问题的时间。**
它的优点就是，智能缩短映射的过程。
它的缺点就是，过于复杂。首先代码优化的种种策略都是基于各种各样的假定，假定不一定会成真，即使费尽心机做的代码优化，也有可能在现实中无法提高性能。其次，不同平台和体系结构的技术特点千差万别，这个映射过程只能单独定制。比如至今Java平台还不能在IOS上做基本映射（即解释器都不行。
 以前JIT刚出现的时候，只是一个挂载的外挂一样的东西。现在开始喧宾夺主取代了解释器。这种转变其实是对中间语言解释器作为一个“薄的胶合层”的一个设计上的自我否定，极大地增加了设计的复杂性。目前对于这种强行加速做得比较好的，就是Java系为代表的各种虚拟机，微软的虚拟机，或者谷歌搞出来的V8引擎（这不知道是不是目前为止设计进生产实践中惟一被广泛应用的动态强行加速）。这几件东西其实无一不是大型商业公司的强大支持的产物。现在主流的动态语言似乎都是社区在弄，没那么多资源来搞这个，是他们没有好的JIT的一个关键因素。本来动态语言的应用场景就不是为了追求高性能，更何况现在各种应用场景下的瓶颈大部分都在语言之外，语言的性能考量又是一个比较次要的需求了。