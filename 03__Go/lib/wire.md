---
title: "Golang依赖注入框架wire"
date: 2020-08-11 15:10:43 +0800
lastmod: 2020-08-11 09:12:32 +0800
draft: false
tags: ["go lib"]
categories: ["go"]
author: "Claymore"

---



## wrie

https://github.com/google/wire

安装：go get github.com/google/wire/cmd/wire



### start

项目中简单创建两个文件：

main.go:

```go
package main

import "fmt"

type Message struct {
   msg string
}
type Greeter struct {
   Message Message
}

type Event struct {
   Greeter Greeter
}

func NewMessage(msg string) Message {
   return Message{
      msg:msg,
   }
}

func NewGreeter(m Message) Greeter {
   return Greeter{Message: m}
}

func NewEvent(g Greeter) Event {
   return Event{Greeter: g}
}
func (e Event) Start() {
   msg := e.Greeter.Greet()
   fmt.Println(msg)
}
func (g Greeter) Greet() Message {
   return g.Message
}

func main() {
   message := NewMessage("hello world")
   greeter := NewGreeter(message)
   event := NewEvent(greeter)

   event.Start()
}
```

上述main.go 是一个简单创建event结构的过程，使用wire框架可以简化 main() 函数中初始化的过程：

wire.go:

``` go
// +build wireinject  //  用于告诉编译器无需编译该文件
// The build tag makes sure the stub is not built in the final build.

package main

import "github.com/google/wire"

// InitializeEvent 声明injector的函数签名
func InitializeEvent(msg string) Event {
	wire.Build(NewEvent, NewGreeter, NewMessage)
	return Event{}  //返回值没有实际意义，只需符合函数签名即可
}
```

在当下目录执行：wrie

``` sh
E:\gitCompany\src\goSrcTest\wrieTest>wire
wire: goSrcTest/wrieTest: wrote E:\gitCompany\src\goSrcTest\wrieTest\wire_gen.go
```

生成了一个新文件wrie_gen.go:

``` go
// Code generated by Wire. DO NOT EDIT.

//go:generate wire     
//+build !wireinject

package main

// Injectors from wrie.go:

func InitializeEvent(msg string) Event {
	message := NewMessage(msg)
	greeter := NewGreeter(message)
	event := NewEvent(greeter)
	return event
}
```

可见，wire 自动确定依赖，自动完成结构体的初始化

此时 main.go 中的 main函数可以改为：

``` go
// 使用wire后
func main() {
	event := InitializeEvent("hello_world")
	event.Start()
}
```

这样看代码是不是少了一些。



### +build

`+build`其实是 Go 语言的一个特性。类似 C/C++ 的条件编译，在执行`go build`时可传入一些选项，根据这个选项决定某些文件是否编译

`wire`工具只会处理有`wireinject`的文件，所以我们的`wire.go`文件要加上这个。生成的`wire_gen.go`是给我们来使用的，`wire`不需要处理，故有`!wireinject`。



### provider 和 injector

`provider`和`injector`是`wire`的两个核心概念。可以简单的理解为，构造器和注入器。

通过提供`provider`函数，让`wire`知道如何产生这些依赖对象。`wire`根据我们定义的`injector`函数签名，生成完整的`injector`函数，`injector`函数是最终我们需要的函数，它将按依赖顺序调用`provider`。

在上方例子中， `NewMessage,NewGreeter,NewEvent`都是`provider`，`wire_gen.go`中的`InitializeEvent`函数是`injector`，可以看到`injector`通过**按依赖顺序调用**`provider`来生成我们需要的对象`Event`。



### 参数

在 上述 wire.go 中 InitializeEvent(msg string) 有一个msg参数，这个字符串参数是给：

``` 
message := NewMessage(msg)
greeter := NewGreeter(message)
event := NewEvent(greeter)
```

NewMessage使用的，如果我们的NewGreeter也接收一个字符串参数呢？如：

`greete := NewGreeter(message, msgstr)`， 这里的msgstr也是字符串，会默认接收msg.

这样一来，initializeEvent中的str参数都会传入不同的构造函数。

所以，在参数较多的时候建议创建一个建构体，或者用其他类型声明一下（type）.

构造器需要的参数（或者叫依赖）会从参数中查找或通过其它构造器生成。决定选择哪个参数或构造器完全根据类型。如果参数或构造器生成的对象有类型相同的情况，运行`wire`工具时会报错。



### ProviderSet

当一些`provider`通常是一起使用的时候，可以使用**provider set**将它们组织起来:

``` go
// EventSet Event通常是一起使用的一个集合，使用wire.NewSet进行组合
var EventSet  = wire.NewSet(NewEvent, NewMessage, NewGreeter) 

func InitializeEvent(msg string) Event{
	//wire.Build(NewEvent, NewGreeter, NewMessage)
	wire.Build(EventSet) 
	return Event{}
}
```

这样的好处是可以直接修改set，而不是修改各处的Intitialize.





### 接口绑定

main.go

``` go
package main
import (
  "fmt"
  "github.com/google/wire"
)
// User 用户对象
type User struct {
}
// UserService
type UserService struct {
  userRepo UserRepository // <-- UserService依赖UserRepository接口
}
// NewUserService *UserService构造函数
func NewUserService(userRepo UserRepository) *UserService {
  return &UserService{
     userRepo: userRepo,
  }
}
// UserExist 判断指定ID的用户是否存在
func (u *UserService) UserExist(id int) bool {
   _, err := u.userRepo.GetUserByID(id)
   return err == nil
}
// UserRepository 存放User对象的数据仓库接口,eg: mysql,restful api ....
type UserRepository interface {
  // GetUserByID 根据ID获取User, 如果找不到User返回对应错误信息
  GetUserByID(id int) (*User, error)
}

// mockUserRepo 模拟一个UserRepository实现
type mockUserRepo struct {
  foo string
  bar int
}
// GetUserByID UserRepository接口实现
func (u *mockUserRepo) GetUserByID(id int) (*User, error) {
  return &User{}, nil
}
// NewMockUserRepo *mockUserRepo构造函数
func NewMockUserRepo(foo string, bar int) *mockUserRepo {
  return &mockUserRepo{
    foo: foo,
    bar: bar,
  }
}
// MockUserRepoSet 将 *mockUserRepo与UserRepository绑定
var MockUserRepoSet = wire.NewSet(NewMockUserRepo, wire.Bind(new(UserRepository), new(*mockUserRepo)))

func main() {
  u := InitializeUserService("foo", 0)
  fmt.Println(u.UserExist(1))
}
```



wire.go

``` go

// +build wireinject
// The build tag makes sure the stub is not built in the final build.
package main
import "github.com/google/wire"
func InitializeUserService(foo string, bar int) (*UserService){
   wire.Build(NewUserService,MockUserRepoSet)  
   return nil
}
```



wire_gen.go

``` go
// Code generated by Wire. DO NOT EDIT.
//go:generate wire
//+build !wireinject
package main
// Injectors from wire.go:
func InitializeUserService(foo string, bar int) *UserService {
  mainMockUserRepo := NewMockUserRepo(foo, bar)
  userService := NewUserService(mainMockUserRepo)
  return userService
}
```

`UserService`依赖`UserRepository`接口，其中`mockUserRepo`是`UserRepository`的一个实现，由于在Go的最佳实践中，更推荐返回具体实现而不是接口。所以`mockUserRepo`的`provider`函数返回的是`*mockUserRepo`这一具体类型。`wire`无法自动将具体实现与接口进行关联，我们需要显示声明它们之间的关联关系。通过`wire.NewSet`和`wire.Bind`将`*mockUserRepo`与`UserRepository`进行绑定



### 返回错误

initialize第二个参数可以返回错误，因为构造函数有的需要返回错误，如：

``` go
// NewAPIClient  APIClient构造函数，如果入参校验失败，返回错误原因
func NewAPIClient(c Config) (*APIClient,error) { // <-- 第二个参数设置成error
	if c.RemoteAddr == "" {
		return nil, errors.New("没有设置远程地址")
	}
	return &APIClient{
		c:c,
	},nil
}
```

有的不需要返回，当其中有返回错误的构造函数时，我们需要将initialize第二个参数返回错误。

``` go
func InitializeClient(config Config) (*Service, error) { // <-- 第二个参数设置成error
	wire.Build(NewService,NewAPIClient)
	return nil,nil
}
```





### cleanup 清理函数

当`provider`生成的对象需要一些cleanup处理，比如关闭文件，关闭数据库连接等操作时，依然可以通过设置`provider`的返回值来达到这样的效果：

```
// FileReader
type FileReader struct {
	f *os.File
}
// NewFileReader *FileReader 构造函数，第二个参数是cleanup function
func NewFileReader(filePath string) (*FileReader, func(), error){
	f, err := os.Open(filePath)
	if err != nil {
	    return nil,nil,err
	}
	fr := &FileReader{
	    f:f,
	}
	fn := func() {
	    log.Println("cleanup") 
	    fr.f.Close()
	}
	return fr,fn,nil
}
复制代码
```

跟返回错误类似，将`provider`的第二个返回参数设置成`func()`用于返回cleanup function，上述例子中在第三个参数中返回了`error`，但这是可选的：

wire对provider的返回值个数和顺序有所规定：

 1. 第一个参数是需要生成的依赖对象
 2. 如果返回2个返回值，第二个参数必须是func()或者error
 3. 如果返回3个返回值，第二个参数必须是func()，第三个参数则必须是error



eg:https://github.com/DrmagicE/wire-examples