---
title: linux进阶
date: 2017-02-22 10:12:45
categories: linux
header-img:
tags: linux
---



### 比较合并

比较

`diff -y [file1][flie2]` 同行输出两个文件的不同

`diff -u [file1][flie2]`以补丁格式输出两个文件的不同

`diff -Nu [file1][file2]>[patchfile]`将不同输出到补丁文件

`patch -p[n]<[patchfile]` 打补丁文件，n一般为0，目录级联



### 环境变量

`$PATH`可看当前的环境变量

`export PATH = $PATH:/home/study`添加/home/study环境变量

`export hello=/home/study`

`cd hello`



所有用户的环境变量：/etc/profile文件
root用户的环境变量：~/.bashrc文件
非root用户的环境变量：/home/非root用户名/.bashrc文件



更新上方环境变量后需要刷新后让其生效： source + 上方文件



#### 修改环境变量

- 当前终端

  在当前终端中输入：`export PATH=$PATH:<你的要加入的路径>`

  不过上面的方法只适用于当前终端，一旦当前终端关闭或在另一个终端中，则无效。

   **注意**这个方法会让其他环境变量无效，尽量不要用这样的方式。

- 当前用户

  在用户主目录下有一个 .bashrc 隐藏文件，可以在此文件中加入 PATH 的设置如下：

  `vi ~/.bashrc`

  加入：

  `export PATH=<你的要加入的路径>:$PATH`

  如果要加入多个路径，只要：

  `export PATH=<你要加入的路径1>:<你要加入的路径2>: ...... :$PATH`

  当中每个路径要以冒号分隔。

  这样每次登录都会生效

- 所有用户

  `sudo vi /etc/profile `

  加入：
  export PATH=<你要加入的路径>:$PATH

  就可以了。

  终端输入：echo $PATH 可以查看环境变量




### 内存

​      查看内存：`free `   

      ```
[root@bogon img]# free -g
             total       used       free     shared    buffers     cached
Mem:            31         19         11          1          0         10
-/+ buffers/cache:          9         22
Swap:            0          0          0

      ```

解释下内存的组成：

![](http://ojynuthay.bkt.clouddn.com/linux%E5%86%85%E5%AD%98.png)





​     shared: 多个进程共享的内存总额

​     `- buffers/cache` : 程序实际吃掉的内存, 第二行used

​    `+ buffers/cache` :  可挪用的内存, 第二行free, 这里值得留意，它是能够回收的，**它是机器真正可用内存**

​     图中： 

```
cached + buffers + free = + buffers/cache  
1482   + 36      + 826   =  2344
```



​     内存有物理内存和虚拟内存之说，物理内存是什么自然无需解释，虚拟内存实际是物理内存的抽象，多数情况下，出于方便性的考虑，程序访问的都是虚拟内存地址，然后操作系统会把它翻译成物理内存地址。 
很多人会把虚拟内存和Swap混为一谈.



#### Swap

实际上Swap只是虚拟内存引申出的一种技术而已：操作系统一旦物理内存不足，为了腾出内存空间存放新内容，就会把当前物理内存中的内容放到交换分区里，稍后用到的时候再取回来，需要注意的是，Swap的使用可能会带来性能问题，偶尔为之无需紧张，糟糕的是物理内存和交换分区频繁的发生数据交换，这被称之为Swap颠簸，一旦发生这种情况，先要明确是什么原因造成的，如果是内存不足就好办了，加内存就可以解决，不过有的时候即使内存充足也可能会出现这种问题，



#### buffer和cache

对于操作系统来说：

```
buffer（缓冲）是为了提高内存和硬盘（或其他I/O设备）之间的数据交换的速度而设计的。 cache（缓存）是为了提高cpu和内存之间的数据交换速度而设计的，也就是平常见到的一级缓存、二级缓存
```

对于linux系统来说：free命令会显示buffers和cached

buffers与cached都是内存操作，用来保存系统曾经打开过的文件以及文件属性信息，这样当操作系统需要读取某些文件时，会首先在buffers 与cached内存区查找。

　　buffers是用来缓冲块设备做的，它只记录文件系统的元数据（metadata）以及 tracking in-flight pages，而cached是用来给文件做缓冲。

更通俗一点说：buffers主要用来存放目录里面有什么内容，文件的属性以及权限等等。而cached直接用来记忆我们打开过的文件和程序。Linux都会尽可能的把文件缓存到内存里，这样下次访问的时候，就可以直接从内存中取结果，所以cached一栏的数值非常的大，不过不用担心，这部分内存是可回收的，操作系统会按照LRU算法淘汰冷数据。

所以一般cache会比较大。





### 进程

#### 进程的分类

第一个角度来看，我们可以分为用户进程与系统进程

- 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。
- 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且，该进程的运行不受用户的干预，即使是root用户也不能干预系统进程的运行。

第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程

- 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。
- 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。
- 守护进程：守护进程是一直运行的一种进程，经常在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如httpd进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond） 进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。



#### fork和exec()

**fork()** 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等

**exec()** 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段

#### 僵尸进程和孤儿进程

子进程就是父进程通过系统调用 `fork()` 而产生的复制品，`fork()` 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，指挥在执行 `exec()` 之后才会不同，

子进程代码执行部分其实已经结束执行了，系统的资源也基本归还给系统了，但是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。

**僵尸进程已经放弃了几乎所有的内存空间，没有任何执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。**

#### init 进程

进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 `fork()` 创建出一个子进程运行 `/sbin/init` 可执行文件,而该进程就是 PID=1 的进程1，也就是 init 进程，而进程 0 就转为交换进程（也被称为空闲进程），而进程 1 （init 进程）是第一个普通用户态的进程,再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。

`init 0~7`:

0 - halt (Do NOT set initdefault to this)   //停机(不要把initdefault设置为零为0，因为这样会使[Linux](http://lib.csdn.net/base/linux)无法启动)
 1 - Single user mode                    //单用户模式，就像WinXP下的安全模式
 2 - Multiuser, without NFS (The same as 3, if you do not have networking)     //多用户，但没有NFS
 3 - Full multiuser mode                 //完全多用户模式，即命令行界面。图形界面完全关闭。如果窗口中有文件未保存，将丢失。用init 5 可以回到图形界面，但原来的进程已死。
 4 - unused          //一般不用，但在一些特殊情况下可以用他来做一些事情
 5 - X11                //选择此项，系统在登录时将进入图形化登录界面
 6 - reboot (Do NOT set initdefault to this)    //重新启动(不要把initdefault设置为6，因为这样会使Linux不断重新启动)



alt+ctrl+f1~f7可以切换多个命令界面。



#### 进程组和Session

每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。

session:

Linux中的session跟web的session有点类似，也是在一个用户登录到主机，那么就建立了一个session，但是它的维系是基于连接的，那么该对于这个会话存在两种的维持方法

    1. 本地连接：就是说用户是在主机本机上进行的登录，直接通过键盘和屏幕和主机进行交互。
    2. 远程连接：用户通过互联网进行连接，比如基于ssh，连接都是经过加密的。

![](http://ojynuthay.bkt.clouddn.com/session.png)

session是一个或多个进程组的集合。

Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个jobs囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他jobs在后台运行。

> **前台**（foreground）就是在终端中运行，与你能有交互的
>
> **后台**（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程

* &符号可以让我们的命令在后台中运行
* `ctrl+z`使我们的当前工作停止并丢到后台中去
* `jobs` 查看后台被停止的工作
* `fg [%jobnumber]`将后台工作拿到前台
* `bg [%jobnumber]`后台停止的工作再运作

#### kill

结束进程

```
#kill的使用格式如下
kill -signal %jobnumber

#signal从1-64个信号值可以选择，可以这样查看
kill －l
```

其中常用的有这些信号值

| 信号值  | 作用                  |
| ---- | ------------------- |
| -1   | 重新读取参数运行，类似与restart |
| -2   | 如同 ctrl+c 的操作退出     |
| -9   | 强制终止该任务             |
| -15  | 正常的方式终止该任务          |

若是在使用kill＋信号值然后直接加数字的话，这个数字代表的是 pid，你将会对 pid 对应的进程做操作

若是在使用kill+信号值然后％jobnumber，这时所操作的对象才是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID



#### 查看进程

top 动态实时查看进程的状态。

ps 静态查看当前的进程信息，打印当前进程快照

###### top

![](http://ojynuthay.bkt.clouddn.com/top.png)

我们看到 top 显示的第一排，

| 内容                           | 解释                    |
| ---------------------------- | --------------------- |
| top                          | 表示当前程序的名称             |
| 11:05:18                     | 表示当前的系统的时间            |
| up 8 days,17:12              | 表示该机器已经启动了多长时间        |
| 1 user                       | 表示当前系统中只有一个用户         |
| load average: 0.29,0.20,0.25 | 分别对应1、5、15分钟内cpu的平均负载 |

load average 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待CPU的平均进程数相关的一个计算值。

假设我们的系统是单CPU单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。

- load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；
- load < 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；
- load = 1 的时候就意味着桥已经被车给沾满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；
- load > 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力的工作了，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２，大于３，超过 CPU 工作能力的 2，３。而若是这个值 > 5 说明系统已经在超负荷运作了。

这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过一下的命令来查看 CPU 的个数与核心数

```
#查看物理CPU的个数
#cat /proc/cpuinfo |grep "physical id"|sort |uniq|wc -l

#每个cpu的核心数
cat /proc/cpuinfo |grep "physical id"|grep "0"|wc -l
```

来看 top 的第二行数据，基本上第二行是进程的一个情况统计

| 内容              | 解释         |
| --------------- | ---------- |
| Tasks: 26 total | 进程总数       |
| 1 running       | 1个正在运行的进程数 |
| 25 sleeping     | 25个睡眠的进程数  |
| 0 stopped       | 没有停止的进程数   |
| 0 zombie        | 没有僵尸进程数    |

来看 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了

| 内容             | 解释                                       |
| -------------- | ---------------------------------------- |
| Cpu(s): 1.0%us | 用户空间占用CPU百分比                             |
| 1.0% sy        | 内核空间占用CPU百分比                             |
| 0.0%ni         | 用户进程空间内改变过优先级的进程占用CPU百分比                 |
| 97.9%id        | 空闲CPU百分比                                 |
| 0.0%wa         | 等待输入输出的CPU时间百分比                          |
| 0.1%hi         | 硬中断(Hardware IRQ)占用CPU的百分比               |
| 0.0%si         | 软中断(Software IRQ)占用CPU的百分比               |
| 0.0%st         | (Steal time) 是当 hypervisor 服务另一个虚拟处理器的时候，虚拟 CPU 等待实际 CPU 的时间的百分比 |

CPU 利用率，是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。

来看 top 的第四行数据，这一行基本上是内存的一个使用情况的统计了

| 内容             | 解释         |
| -------------- | ---------- |
| 8176740 total  | 物理内存总量     |
| 8032104 used   | 使用的物理内存总量  |
| 144636 free    | 空闲内存总量     |
| 313088 buffers | 用作内核缓存的内存量 |

> **注意**
>
> 系统的中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和

来看 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了

| 内容     | 解释                                       |
| ------ | ---------------------------------------- |
| total  | 交换区总量                                    |
| used   | 使用的交换区总量                                 |
| free   | 空闲交换区总量                                  |
| cached | 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖 |

在下面就是进程的一个情况了

| 列名      | 解释                                   |
| ------- | ------------------------------------ |
| PID     | 进程id                                 |
| USER    | 该进程的所属用户                             |
| PR      | 该进程执行的优先级priority 值                  |
| NI      | 该进程的 nice 值                          |
| VIRT    | 该进程任务所使用的虚拟内存的总数                     |
| RES     | 该进程所使用的物理内存数，也称之为驻留内存数               |
| SHR     | 该进程共享内存的大小                           |
| S       | 该进程进程的状态: S=sleep R=running Z=zombie |
| %CPU    | 该进程CPU的利用率                           |
| %MEM    | 该进程内存的利用率                            |
| TIME+   | 该进程活跃的总时间                            |
| COMMAND | 该进程运行的名字                             |

> **注意**
>
> **NICE 值**叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低
>
> **PR 值**表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是MAX_PRIO，它的值为140。Linux实际上实现了140个优先级范围，取值范围是从0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时的值，而 100 - 139 是给用户的。
>
> 其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同
>
> **VIRT **任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数

在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的

| 常用交互命令 | 解释                                       |
| ------ | ---------------------------------------- |
| q      | 退出程序                                     |
| I      | 切换显示平均负载和启动时间的信息                         |
| P      | 根据CPU使用百分比大小进行排序                         |
| M      | 根据驻留内存大小进行排序                             |
| i      | 忽略闲置和僵死的进程，这是一个开关式命令                     |
| k      | 终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用15信号，不能正常结束则使用9信号。安全模式下该命令被屏蔽。 |

###### ps

* `ps aux`罗列出所有的进程信息
* `ps aux | grep zsh`查找某个进程
* `ps －afxo user,ppid,pid,pgid,command`自定义显示参数
* `pstree`可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程的之间的相关性。


### 



### Mount

 `mount [-t 文件系统][-L label名][-o 额外选项]] 设备名称名 挂载点`

* 单纯输mount 会显示当前的挂载信息， 加上`-l `会显示label名
* -t 欲挂载的文件系统类型： ext2,ext3 等。
* -L 除了利用设备文件名（如/dev/hdc6）, 还可以用它的卷标名称（Label)来进行挂载。
* -o 可以跟上额外选项，如账号，密码， 读写权限等。

eg: 

将`/dev/hdc6`挂载到`/mnt/hdc6` 上：

`mkdir /mnt/hdc6`

`mount /dev/hdc6 /mnt/hdc6`

仅仅这样我们就可以进行方便的挂载，可以通过df查看， 为什么如此方便，因为该命令会自动匹配我们的super block 